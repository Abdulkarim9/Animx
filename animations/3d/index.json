[
    {
        "id": "3d-parallax-depth-card",
        "title": "3D Parallax Depth Card",
        "description": "Professional parallax effect card with multiple layers and depth perception.",
        "category": "3d",
        "tags": ["3d", "parallax", "depth", "professional"],
        "html": "<div class=\"parallax-card\">\n  <div class=\"parallax-card-content\">\n    <div class=\"parallax-layer layer-bg\" data-speed=\"0.1\"></div>\n    <div class=\"parallax-layer layer-middle\" data-speed=\"0.2\"></div>\n    <div class=\"parallax-layer layer-top\" data-speed=\"0.35\"></div>\n    <div class=\"parallax-layer layer-text\" data-speed=\"0.25\">\n      <div class=\"layer-icon\">\n        <svg viewBox=\"0 0 24 24\" width=\"36\" height=\"36\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n          <path d=\"M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z\"></path>\n        </svg>\n      </div>\n      <h2>ENTERPRISE</h2>\n      <p>SECURITY SOLUTIONS</p>\n    </div>\n  </div>\n</div>",
        "css": ".parallax-card {\n  width: 320px;\n  height: 200px;\n  perspective: 1000px;\n  position: relative;\n  margin: 0 auto;\n}\n\n.parallax-card-content {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  transform-style: preserve-3d;\n  border-radius: 12px;\n  box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);\n  overflow: hidden;\n}\n\n.parallax-layer {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background-position: center center;\n  background-size: cover;\n  background-repeat: no-repeat;\n  transition: transform 0.3s ease-out;\n}\n\n.layer-bg {\n  background: linear-gradient(135deg, #1a2151 0%, #283593 100%);\n  transform: translateZ(0px);\n}\n\n.layer-middle {\n  background: radial-gradient(circle at 70% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 70%);\n  transform: translateZ(20px);\n  opacity: 0.8;\n}\n\n.layer-top {\n  background: linear-gradient(90deg, transparent 40%, rgba(255, 255, 255, 0.08) 100%);\n  transform: translateZ(40px);\n  opacity: 0.6;\n}\n\n.layer-text {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  transform: translateZ(60px);\n  pointer-events: none;\n  color: white;\n  text-align: center;\n  font-family: 'Inter', sans-serif;\n}\n\n.layer-icon {\n  color: rgba(255, 255, 255, 0.9);\n  margin-bottom: 15px;\n  filter: drop-shadow(0 2px 6px rgba(0, 0, 0, 0.3));\n}\n\n.layer-text h2 {\n  font-size: 24px;\n  font-weight: 700;\n  margin: 0;\n  letter-spacing: 2px;\n  text-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);\n}\n\n.layer-text p {\n  font-size: 14px;\n  letter-spacing: 1.5px;\n  margin: 8px 0 0;\n  opacity: 0.8;\n  font-weight: 500;\n}\n\n.parallax-card::after {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(135deg, rgba(26, 33, 81, 0.5) 0%, rgba(40, 53, 147, 0.2) 100%);\n  border-radius: 12px;\n  z-index: 10;\n  opacity: 0;\n  transition: opacity 0.3s ease;\n  pointer-events: none;\n}\n\n.parallax-card:hover::after {\n  opacity: 1;\n}",
        "js": "// Initialize the parallax effect\nconst card = this.querySelector('.parallax-card');\nconst layers = this.querySelectorAll('.parallax-layer');\n\nfunction handleMouseMove(e) {\n  const rect = card.getBoundingClientRect();\n  const centerX = rect.left + rect.width / 2;\n  const centerY = rect.top + rect.height / 2;\n  const mouseX = e.clientX - centerX;\n  const mouseY = e.clientY - centerY;\n  \n  layers.forEach(layer => {\n    const speed = parseFloat(layer.getAttribute('data-speed')) || 0;\n    const rotateY = mouseX * speed * 0.03;\n    const rotateX = -mouseY * speed * 0.03;\n    \n    layer.style.transform = `translateZ(${speed * 100}px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n  });\n}\n\ncard.addEventListener('mousemove', handleMouseMove);\ncard.addEventListener('mouseleave', () => {\n  layers.forEach(layer => {\n    const speed = parseFloat(layer.getAttribute('data-speed')) || 0;\n    layer.style.transform = `translateZ(${speed * 100}px)`;\n  });\n});\n\n// Add subtle entrance animation\nfunction animateIn() {\n  setTimeout(() => {\n    card.style.transform = 'translateY(0)';\n    card.style.opacity = '1';\n    \n    layers.forEach((layer, index) => {\n      setTimeout(() => {\n        const speed = parseFloat(layer.getAttribute('data-speed')) || 0;\n        layer.style.transform = `translateZ(${speed * 100}px)`;\n        layer.style.opacity = '1';\n      }, 100 * index);\n    });\n  }, 300);\n}\n\n// Setup initial state\ncard.style.transform = 'translateY(20px)';\ncard.style.opacity = '0';\ncard.style.transition = 'transform 0.6s ease-out, opacity 0.6s ease-out';\n\nlayers.forEach(layer => {\n  layer.style.transform = 'translateZ(0)';\n  layer.style.opacity = '0';\n  layer.style.transition = 'transform 0.6s ease-out, opacity 0.6s ease-out';\n});\n\n// Start animation\nanimateIn();"
    },
    {
        "id": "3d-isometric-cube-grid",
        "title": "3D Isometric Cube Grid",
        "description": "Professional isometric cube grid with hover interactions and subtle animations.",
        "category": "3d",
        "tags": ["3d", "isometric", "grid", "professional"],
        "html": "<div class=\"isometric-container\">\n  <div class=\"isometric-grid\">\n    <div class=\"iso-cube\"></div>\n    <div class=\"iso-cube\"></div>\n    <div class=\"iso-cube\"></div>\n    <div class=\"iso-cube\"></div>\n    <div class=\"iso-cube\"></div>\n    <div class=\"iso-cube\"></div>\n    <div class=\"iso-cube\"></div>\n    <div class=\"iso-cube\"></div>\n    <div class=\"iso-cube\"></div>\n  </div>\n</div>",
        "css": ".isometric-container {\n  width: 300px;\n  height: 200px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  perspective: 1000px;\n}\n\n.isometric-grid {\n  transform-style: preserve-3d;\n  transform: rotateX(45deg) rotateZ(45deg);\n  display: grid;\n  grid-template-columns: repeat(3, 40px);\n  grid-template-rows: repeat(3, 40px);\n  gap: 10px;\n}\n\n.iso-cube {\n  position: relative;\n  width: 40px;\n  height: 40px;\n  transform-style: preserve-3d;\n  transform: translateZ(0);\n  transition: transform 0.3s, box-shadow 0.3s, background-color 0.3s;\n  cursor: pointer;\n  background: rgba(100, 120, 240, 0.8);\n  box-shadow: 0 0 20px rgba(100, 120, 240, 0.3);\n}\n\n.iso-cube:hover {\n  transform: translateZ(20px);\n  background: rgba(120, 150, 255, 0.9);\n  box-shadow: 0 10px 30px rgba(100, 120, 240, 0.5);\n  z-index: 10;\n}\n\n.iso-cube:nth-child(odd) {\n  background: rgba(80, 100, 220, 0.8);\n  animation: float 4s infinite ease-in-out;\n}\n\n.iso-cube:nth-child(2n+1) {\n  animation-delay: 0.5s;\n}\n\n.iso-cube:nth-child(3n+1) {\n  animation-delay: 1s;\n}\n\n.iso-cube:nth-child(5) {\n  background: rgba(120, 150, 255, 0.9);\n  animation-delay: 1.5s;\n}\n\n@keyframes float {\n  0%, 100% {\n    transform: translateZ(0);\n  }\n  50% {\n    transform: translateZ(10px);\n  }\n}",
        "js": "// Initialize the isometric grid\nconst grid = this.querySelector('.isometric-grid');\nconst cubes = this.querySelectorAll('.iso-cube');\n\n// Add click interaction\ncubes.forEach(cube => {\n  cube.addEventListener('click', function() {\n    this.style.transform = `translateZ(${Math.random() * 30 + 20}px)`;\n    \n    setTimeout(() => {\n      this.style.transform = '';\n    }, 500);\n  });\n});\n\n// Add subtle rotation to the grid on mouse move\nthis.addEventListener('mousemove', (e) => {\n  const rect = this.getBoundingClientRect();\n  const centerX = rect.left + rect.width / 2;\n  const centerY = rect.top + rect.height / 2;\n  \n  const rotateX = (e.clientY - centerY) * 0.01;\n  const rotateZ = (e.clientX - centerX) * 0.01;\n  \n  grid.style.transform = `rotateX(${45 + rotateX}deg) rotateZ(${45 + rotateZ}deg)`;\n});\n\nthis.addEventListener('mouseleave', () => {\n  grid.style.transform = 'rotateX(45deg) rotateZ(45deg)';\n});"
    },
    {
        "id": "3d-flip-card",
        "title": "3D Flip Card",
        "description": "A card that flips in 3D space, revealing content on the back side.",
        "category": "3d",
        "tags": ["3d", "flip", "card"],
        "html": "<div class=\"flip-card\">\n  <div class=\"flip-card-inner\">\n    <div class=\"flip-card-front\">\n      <h3>Hover me</h3>\n      <p>See what's on the back!</p>\n    </div>\n    <div class=\"flip-card-back\">\n      <h3>Hello there!</h3>\n      <p>This is the back of the card.</p>\n    </div>\n  </div>\n</div>",
        "css": ".flip-card {\n  width: 250px;\n  height: 150px;\n  perspective: 1000px;\n}\n\n.flip-card-inner {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  transition: transform 0.8s;\n  transform-style: preserve-3d;\n}\n\n.flip-card:hover .flip-card-inner {\n  transform: rotateY(180deg);\n}\n\n.flip-card-front, .flip-card-back {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  backface-visibility: hidden;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  border-radius: 8px;\n  padding: 1rem;\n}\n\n.flip-card-front {\n  background-color: #7c4dff;\n  color: white;\n}\n\n.flip-card-back {\n  background-color: #3f1dcb;\n  color: white;\n  transform: rotateY(180deg);\n}",
        "js": ""
    },
    {
        "id": "interactive-floating-elements",
        "title": "Interactive Floating Elements",
        "description": "A collection of elements that float with realistic physics and respond to mouse interactions.",
        "category": "3d",
        "tags": ["interactive", "physics", "floating", "mouse"],
        "html": "<div class=\"floating-container\">\n  <div class=\"floating-element circle\"></div>\n  <div class=\"floating-element triangle\"></div>\n  <div class=\"floating-element square\"></div>\n  <div class=\"floating-element pentagon\"></div>\n  <div class=\"floating-element star\"></div>\n  <div class=\"instruction\">Move your mouse around to interact</div>\n</div>",
        "css": ".floating-container {\n  position: relative;\n  width: 100%;\n  height: 300px;\n  background: linear-gradient(135deg, #f5f7fa 0%, #eef1f5 100%);\n  border-radius: 8px;\n  overflow: hidden;\n}\n\n.floating-element {\n  position: absolute;\n  border-radius: 50%;\n  cursor: pointer;\n  will-change: transform;\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n}\n\n.circle {\n  width: 50px;\n  height: 50px;\n  background-color: #7c4dff;\n  top: 30%;\n  left: 30%;\n}\n\n.triangle {\n  width: 0;\n  height: 0;\n  border-left: 30px solid transparent;\n  border-right: 30px solid transparent;\n  border-bottom: 60px solid #ff4d7c;\n  border-radius: 0;\n  top: 60%;\n  left: 20%;\n}\n\n.square {\n  width: 45px;\n  height: 45px;\n  background-color: #4dcaff;\n  border-radius: 3px;\n  top: 40%;\n  left: 60%;\n}\n\n.pentagon {\n  width: 55px;\n  height: 52px;\n  background-color: #ffca4d;\n  clip-path: polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%);\n  border-radius: 0;\n  top: 50%;\n  left: 75%;\n}\n\n.star {\n  width: 60px;\n  height: 60px;\n  background-color: #4dff60;\n  clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);\n  border-radius: 0;\n  top: 20%;\n  left: 50%;\n}\n\n.instruction {\n  position: absolute;\n  bottom: 15px;\n  width: 100%;\n  text-align: center;\n  color: #7c4dff;\n  font-style: italic;\n  animation: fadeInOut 2s ease-in-out infinite;\n}\n\n@keyframes fadeInOut {\n  0%, 100% { opacity: 0.5; }\n  50% { opacity: 1; }\n}",
        "js": "// Interactive Floating Elements\nfunction initFloatingElements() {\n  const container = document.querySelector('.floating-container');\n  const elements = document.querySelectorAll('.floating-element');\n  \n  if (!container || !elements.length) return;\n  \n  // Initialize element positions with slight random movement\n  elements.forEach(el => {\n    const randomX = Math.random() * 10 - 5;\n    const randomY = Math.random() * 10 - 5;\n    \n    // Store original positions\n    const rect = el.getBoundingClientRect();\n    const containerRect = container.getBoundingClientRect();\n    \n    el.dataset.originalX = (rect.left - containerRect.left) + randomX;\n    el.dataset.originalY = (rect.top - containerRect.top) + randomY;\n    \n    // Start floating animation using CSS\n    el.style.setProperty('--float-x', Math.random() * 20 - 10 + 'px');\n    el.style.setProperty('--float-y', Math.random() * 20 - 10 + 'px');\n    el.style.setProperty('--float-rotate', Math.random() * 20 - 10 + 'deg');\n    el.style.setProperty('--float-duration', 3 + Math.random() * 4 + 's');\n    el.classList.add('floating');\n  });\n  \n  // Add mouse move interactivity\n  container.addEventListener('mousemove', e => {\n    const containerRect = container.getBoundingClientRect();\n    const mouseX = e.clientX - containerRect.left;\n    const mouseY = e.clientY - containerRect.top;\n    \n    elements.forEach(el => {\n      // Calculate distance from mouse to element\n      const elRect = el.getBoundingClientRect();\n      const elCenterX = elRect.left - containerRect.left + elRect.width / 2;\n      const elCenterY = elRect.top - containerRect.top + elRect.height / 2;\n      \n      const distanceX = mouseX - elCenterX;\n      const distanceY = mouseY - elCenterY;\n      const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n      \n      // Create repulsion effect within a certain radius\n      const radius = 150;\n      \n      if (distance < radius) {\n        // Calculate force - closer means stronger force\n        const force = (1 - distance / radius) * 25;\n        \n        // Calculate angle\n        const angle = Math.atan2(distanceY, distanceX);\n        \n        // Calculate repulsion movement (opposite direction from mouse)\n        const moveX = -Math.cos(angle) * force;\n        const moveY = -Math.sin(angle) * force;\n        \n        // Apply movement with CSS transitions\n        el.style.transform = 'translate(' + moveX + 'px, ' + moveY + 'px) rotate(' + (mouseX / containerRect.width - 0.5) * 15 + 'deg)';\n        el.style.transition = 'transform 0.6s ease';\n      } else {\n        // Return to floating state if mouse is far away\n        returnToFloating(el);\n      }\n    });\n  });\n  \n  // Return elements to floating state when mouse leaves\n  container.addEventListener('mouseleave', () => {\n    elements.forEach(el => {\n      returnToFloating(el);\n    });\n  });\n  \n  // Make elements clickable for an extra effect\n  elements.forEach(el => {\n    el.addEventListener('click', () => {\n      // Create a fun \"pop\" effect\n      el.classList.add('pop');\n      setTimeout(() => {\n        el.classList.remove('pop');\n      }, 600);\n    });\n  });\n  \n  function returnToFloating(element) {\n    // Reset to original floating animation\n    element.classList.remove('floating');\n    element.style.transform = '';\n    \n    // Re-trigger floating animation\n    setTimeout(() => {\n      element.style.setProperty('--float-x', Math.random() * 20 - 10 + 'px');\n      element.style.setProperty('--float-y', Math.random() * 20 - 10 + 'px');\n      element.style.setProperty('--float-rotate', Math.random() * 20 - 10 + 'deg');\n      element.style.setProperty('--float-duration', 3 + Math.random() * 4 + 's');\n      element.classList.add('floating');\n    }, 10);\n  }\n}\n\n// Initialize the floating elements\ninitFloatingElements();"
    },
    {
        "id": "particle-explosion",
        "title": "Particle Explosion",
        "description": "An explosion of particles that emanate from a central point when triggered.",
        "category": "3d",
        "tags": ["particles", "explosion", "animation"],
        "html": "<div class=\"particle-container\">\n  <button id=\"trigger-particles\" class=\"particle-button\">Explode Particles</button>\n  <div class=\"particles-area\"></div>\n</div>",
        "css": ".particle-container {\n  position: relative;\n  width: 100%;\n  height: 300px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  overflow: hidden;\n  background-color: #f5f5f5;\n  border-radius: 8px;\n}\n\n.particle-button {\n  padding: 0.8rem 1.5rem;\n  background-color: #7c4dff;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n  font-weight: 500;\n  z-index: 10;\n  transition: background-color 0.3s;\n}\n\n.particle-button:hover {\n  background-color: #6436db;\n}\n\n.particles-area {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n}\n\n.particle {\n  position: absolute;\n  background-color: #7c4dff;\n  border-radius: 50%;\n  width: 10px;\n  height: 10px;\n  pointer-events: none;\n  transform: translate(0, 0);\n  opacity: 1;\n}\n\n.particle.explode {\n  animation: particle-fade var(--duration) ease-out forwards;\n}\n\n@keyframes particle-fade {\n  0% {\n    transform: translate(0, 0);\n    opacity: 1;\n  }\n  100% {\n    transform: translate(var(--end-x), var(--end-y));\n    opacity: 0;\n  }\n}",
        "js": "// Particle explosion animation\nfunction createParticleExplosion() {\n  const particlesArea = document.querySelector('.particles-area');\n  const triggerBtn = document.getElementById('trigger-particles');\n  \n  if (!particlesArea || !triggerBtn) return;\n  \n  triggerBtn.addEventListener('click', () => {\n    // Clear any existing particles\n    particlesArea.innerHTML = '';\n    \n    // Get the button position for the explosion center\n    const rect = triggerBtn.getBoundingClientRect();\n    const containerRect = particlesArea.getBoundingClientRect();\n    \n    const centerX = rect.left - containerRect.left + rect.width / 2;\n    const centerY = rect.top - containerRect.top + rect.height / 2;\n    \n    // Create particles\n    const particleCount = 50;\n    \n    for (let i = 0; i < particleCount; i++) {\n      const particle = document.createElement('div');\n      particle.classList.add('particle');\n      \n      // Random size between 5 and 15px\n      const size = 5 + Math.random() * 10;\n      particle.style.width = size + 'px';\n      particle.style.height = size + 'px';\n      \n      // Random color variations\n      const hue = 260 + Math.random() * 40; // Purple variations\n      const saturation = 70 + Math.random() * 30;\n      const lightness = 50 + Math.random() * 20;\n      particle.style.backgroundColor = 'hsl(' + hue + ', ' + saturation + '%, ' + lightness + '%)';\n      \n      // Position at center\n      particle.style.left = centerX + 'px';\n      particle.style.top = centerY + 'px';\n      \n      particlesArea.appendChild(particle);\n      \n      // Animate particle with CSS\n      const angle = Math.random() * Math.PI * 2; // Random angle\n      const distance = 50 + Math.random() * 150; // Random distance\n      const duration = 0.8 + Math.random() * 1.2; // Random duration\n      \n      // Set animation properties and add class\n      particle.style.setProperty('--end-x', Math.cos(angle) * distance + 'px');\n      particle.style.setProperty('--end-y', Math.sin(angle) * distance + 'px');\n      particle.style.setProperty('--duration', duration + 's');\n      particle.classList.add('explode');\n      \n      // Remove particle after animation completes\n      setTimeout(() => {\n        particle.remove();\n      }, duration * 1000);\n    }\n  });\n}\n\ncreateParticleExplosion();"
    },
    {
        "id": "3d-rotating-cube",
        "title": "Premium 3D Rotating Cube",
        "description": "A stunning professional 3D cube with dynamic lighting, reflections, and interactive rotating animations.",
        "category": "3d",
        "tags": ["3d", "cube", "rotation", "interactive", "glossy"],
        "html": "<div class=\"premium-cube-scene\">\n  <div class=\"cube-wrapper\">\n    <div class=\"premium-cube\">\n      <div class=\"cube-face front\">Front</div>\n      <div class=\"cube-face back\">Back</div>\n      <div class=\"cube-face right\">Right</div>\n      <div class=\"cube-face left\">Left</div>\n      <div class=\"cube-face top\">Top</div>\n      <div class=\"cube-face bottom\">Bottom</div>\n    </div>\n  </div>\n  <div class=\"cube-controls\">\n    <div class=\"control-label\">Drag to rotate • Double-click to auto-rotate</div>\n  </div>\n</div>",
        "css": ".premium-cube-scene {\n  width: 100%;\n  max-width: 400px;\n  height: 400px;\n  margin: 0 auto;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n  overflow: hidden;\n  background: radial-gradient(circle at center, rgba(30, 30, 50, 0.3) 0%, rgba(10, 10, 30, 0.7) 100%);\n  border-radius: 16px;\n}\n\n.cube-wrapper {\n  width: 200px;\n  height: 200px;\n  perspective: 1000px;\n  position: relative;\n  transform-style: preserve-3d;\n}\n\n.premium-cube {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  transform-style: preserve-3d;\n  transition: transform 0.5s ease-out;\n  cursor: grab;\n}\n\n.premium-cube.auto-rotate {\n  animation: auto-rotate 12s infinite linear;\n  cursor: default;\n}\n\n.cube-face {\n  position: absolute;\n  width: 200px;\n  height: 200px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 1.8rem;\n  font-weight: 700;\n  letter-spacing: 1px;\n  color: white;\n  backface-visibility: hidden;\n  text-transform: uppercase;\n  border-radius: 4px;\n  border: 1px solid rgba(255, 255, 255, 0.2);\n  background-color: rgba(0, 0, 0, 0.1);\n  box-shadow: inset 0 0 50px rgba(255, 255, 255, 0.1);\n  overflow: hidden;\n}\n\n.cube-face::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: linear-gradient(45deg, transparent 40%, rgba(255, 255, 255, 0.2) 50%, transparent 60%);\n  background-size: 300% 300%;\n  background-position: 0% 0%;\n  animation: light-sweep 5s infinite ease-in-out;\n  z-index: 1;\n  pointer-events: none;\n}\n\n.front {\n  transform: translateZ(100px);\n  background: linear-gradient(135deg, rgba(124, 77, 255, 0.8), rgba(124, 77, 255, 0.5));\n}\n\n.back {\n  transform: rotateY(180deg) translateZ(100px);\n  background: linear-gradient(135deg, rgba(255, 77, 124, 0.8), rgba(255, 77, 124, 0.5));\n}\n\n.right {\n  transform: rotateY(90deg) translateZ(100px);\n  background: linear-gradient(135deg, rgba(77, 202, 255, 0.8), rgba(77, 202, 255, 0.5));\n}\n\n.left {\n  transform: rotateY(-90deg) translateZ(100px);\n  background: linear-gradient(135deg, rgba(255, 202, 77, 0.8), rgba(255, 202, 77, 0.5));\n}\n\n.top {\n  transform: rotateX(90deg) translateZ(100px);\n  background: linear-gradient(135deg, rgba(77, 255, 96, 0.8), rgba(77, 255, 96, 0.5));\n}\n\n.bottom {\n  transform: rotateX(-90deg) translateZ(100px);\n  background: linear-gradient(135deg, rgba(255, 77, 248, 0.8), rgba(255, 77, 248, 0.5));\n}\n\n@keyframes auto-rotate {\n  0% {\n    transform: rotateY(0deg) rotateX(20deg);\n  }\n  100% {\n    transform: rotateY(360deg) rotateX(20deg);\n  }\n}\n\n@keyframes light-sweep {\n  0% {\n    background-position: 200% 100%;\n  }\n  20% {\n    background-position: 100% 50%;\n  }\n  40% {\n    background-position: 0% 0%;\n  }\n  100% {\n    background-position: -200% -100%;\n  }\n}\n\n.cube-controls {\n  position: absolute;\n  bottom: 15px;\n  left: 0;\n  width: 100%;\n  text-align: center;\n  color: rgba(255, 255, 255, 0.8);\n  font-size: 0.85rem;\n}\n\n.control-label {\n  padding: 6px 12px;\n  background: rgba(0, 0, 0, 0.3);\n  border-radius: 20px;\n  display: inline-block;\n  backdrop-filter: blur(5px);\n}\n\n/* Add reflection effect */\n.premium-cube-scene::after {\n  content: '';\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 100px;\n  background: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, rgba(255, 255, 255, 0.1) 100%);\n  transform: rotateX(180deg);\n  transform-origin: bottom;\n  filter: blur(8px);\n  opacity: 0.5;\n  pointer-events: none;\n}\n\n/* Add glow on faces */\n.front, .back, .right, .left, .top, .bottom {\n  box-shadow: 0 0 20px rgba(124, 77, 255, 0.3);\n}\n\n.front { box-shadow: 0 0 30px rgba(124, 77, 255, 0.4); }\n.back { box-shadow: 0 0 30px rgba(255, 77, 124, 0.4); }\n.right { box-shadow: 0 0 30px rgba(77, 202, 255, 0.4); }\n.left { box-shadow: 0 0 30px rgba(255, 202, 77, 0.4); }\n.top { box-shadow: 0 0 30px rgba(77, 255, 96, 0.4); }\n.bottom { box-shadow: 0 0 30px rgba(255, 77, 248, 0.4); }",
        "js": "function initPremiumCube() {\n  const cube = document.querySelector('.premium-cube');\n  if (!cube) return;\n  \n  let isDragging = false;\n  let previousMousePosition = { x: 0, y: 0 };\n  let rotationX = 20;\n  let rotationY = 0;\n  let lastTap = 0;\n  let isAutoRotating = false;\n  \n  // Handle mouse down event\n  cube.addEventListener('mousedown', (e) => {\n    e.preventDefault();\n    isDragging = true;\n    cube.style.cursor = 'grabbing';\n    previousMousePosition = {\n      x: e.clientX,\n      y: e.clientY\n    };\n    \n    // Disable auto-rotation when user starts dragging\n    if (isAutoRotating) {\n      cube.classList.remove('auto-rotate');\n      isAutoRotating = false;\n    }\n  });\n  \n  // Handle double-click event\n  cube.addEventListener('dblclick', (e) => {\n    e.preventDefault();\n    toggleAutoRotation();\n  });\n  \n  // Handle touch events for mobile\n  cube.addEventListener('touchstart', (e) => {\n    e.preventDefault();\n    const touch = e.touches[0];\n    isDragging = true;\n    previousMousePosition = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    \n    // Check for double tap\n    const currentTime = new Date().getTime();\n    const tapLength = currentTime - lastTap;\n    if (tapLength < 300 && tapLength > 0) {\n      toggleAutoRotation();\n    }\n    lastTap = currentTime;\n  });\n  \n  // Handle mouse move event\n  document.addEventListener('mousemove', (e) => {\n    if (!isDragging) return;\n    \n    const currentMousePosition = {\n      x: e.clientX,\n      y: e.clientY\n    };\n    \n    const mouseDelta = {\n      x: currentMousePosition.x - previousMousePosition.x,\n      y: currentMousePosition.y - previousMousePosition.y\n    };\n    \n    // Update rotation based on mouse movement\n    rotationY += mouseDelta.x * 0.5;\n    rotationX += mouseDelta.y * 0.5;\n    \n    // Limit vertical rotation to prevent flipping\n    rotationX = Math.max(-60, Math.min(60, rotationX));\n    \n    // Apply rotation\n    cube.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;\n    \n    previousMousePosition = {\n      x: currentMousePosition.x,\n      y: currentMousePosition.y\n    };\n  });\n  \n  // Handle touch move event\n  document.addEventListener('touchmove', (e) => {\n    if (!isDragging) return;\n    \n    const touch = e.touches[0];\n    const currentMousePosition = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    \n    const mouseDelta = {\n      x: currentMousePosition.x - previousMousePosition.x,\n      y: currentMousePosition.y - previousMousePosition.y\n    };\n    \n    // Update rotation based on touch movement\n    rotationY += mouseDelta.x * 0.5;\n    rotationX += mouseDelta.y * 0.5;\n    \n    // Limit vertical rotation\n    rotationX = Math.max(-60, Math.min(60, rotationX));\n    \n    // Apply rotation\n    cube.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;\n    \n    previousMousePosition = {\n      x: currentMousePosition.x,\n      y: currentMousePosition.y\n    };\n  });\n  \n  // Handle mouse up and mouse leave events\n  document.addEventListener('mouseup', () => {\n    isDragging = false;\n    cube.style.cursor = 'grab';\n  });\n  \n  document.addEventListener('mouseleave', () => {\n    isDragging = false;\n    cube.style.cursor = 'grab';\n  });\n  \n  // Handle touch end event\n  document.addEventListener('touchend', () => {\n    isDragging = false;\n  });\n  \n  // Toggle auto-rotation\n  function toggleAutoRotation() {\n    isAutoRotating = !isAutoRotating;\n    \n    if (isAutoRotating) {\n      // Store current rotation before starting auto-rotation\n      cube.style.transform = `rotateX(20deg) rotateY(0deg)`;\n      cube.classList.add('auto-rotate');\n    } else {\n      cube.classList.remove('auto-rotate');\n      // Restore manual rotation\n      cube.style.transform = `rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;\n    }\n  }\n  \n  // Add subtle movement on initial load\n  let angle = 0;\n  function subtleMovement() {\n    if (!isDragging && !isAutoRotating) {\n      angle += 0.2;\n      const subtleX = rotationX + Math.sin(angle * 0.05) * 1;\n      const subtleY = rotationY + Math.cos(angle * 0.05) * 1;\n      cube.style.transform = `rotateX(${subtleX}deg) rotateY(${subtleY}deg)`;\n    }\n    requestAnimationFrame(subtleMovement);\n  }\n  \n  // Start with auto-rotation\n  toggleAutoRotation();\n  \n  // Start subtle movement loop\n  subtleMovement();\n}\n\n// Initialize the premium 3D cube\ninitPremiumCube();"
    },
    {
        "id": "3d-parallax-tilt",
        "title": "3D Parallax Tilt Effect",
        "description": "An immersive 3D parallax effect that responds to mouse movement creating depth and dimensionality.",
        "category": "3d",
        "tags": ["3d", "parallax", "depth", "mouse", "tilt"],
        "html": "<div class=\"parallax-card\">\n  <div class=\"parallax-content\">\n    <div class=\"parallax-layer bg\" data-depth=\"0.1\"></div>\n    <div class=\"parallax-layer mid\" data-depth=\"0.2\">AnimX</div>\n    <div class=\"parallax-layer front\" data-depth=\"0.3\">3D</div>\n  </div>\n</div>",
        "css": ".parallax-card {\n  width: 300px;\n  height: 200px;\n  margin: 0 auto;\n  perspective: 1000px;\n  cursor: pointer;\n  border-radius: 20px;\n  overflow: hidden;\n  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);\n  transition: box-shadow 0.3s ease;\n}\n\n.parallax-card:hover {\n  box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);\n}\n\n.parallax-content {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  transform-style: preserve-3d;\n  transition: transform 0.1s ease-out;\n  border-radius: 20px;\n  overflow: hidden;\n}\n\n.parallax-layer {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-weight: bold;\n  color: white;\n  will-change: transform;\n  transition: transform 0.1s ease-out;\n}\n\n.bg {\n  background: linear-gradient(135deg, #7c4dff 0%, #4dcaff 100%);\n  transform: translateZ(0);\n}\n\n.mid {\n  font-size: 5rem;\n  text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);\n  transform: translateZ(20px);\n}\n\n.front {\n  font-size: 2rem;\n  color: rgba(255, 255, 255, 0.9);\n  transform: translateZ(40px);\n}",
        "js": "function initParallaxTilt() {\n  const card = document.querySelector('.parallax-card');\n  const content = document.querySelector('.parallax-content');\n  const layers = document.querySelectorAll('.parallax-layer');\n  \n  if (!card || !content || !layers.length) return;\n  \n  // Set initial transforms for layers\n  layers.forEach(layer => {\n    const depth = layer.getAttribute('data-depth');\n    layer.style.transform = `translateZ(${depth * 100}px)`;\n  });\n  \n  // Track mouse position\n  let rect = card.getBoundingClientRect();\n  let mouseX = 0;\n  let mouseY = 0;\n  \n  // Update on window resize\n  window.addEventListener('resize', () => {\n    rect = card.getBoundingClientRect();\n  });\n  \n  // Handle mouse movement\n  card.addEventListener('mousemove', (e) => {\n    mouseX = e.clientX - rect.left - rect.width / 2;\n    mouseY = e.clientY - rect.top - rect.height / 2;\n    \n    const rotateY = mouseX * 0.05;\n    const rotateX = -mouseY * 0.05;\n    \n    content.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n    \n    // Move layers based on their depth\n    layers.forEach(layer => {\n      const depth = layer.getAttribute('data-depth');\n      const translateX = mouseX * depth * 0.1;\n      const translateY = mouseY * depth * 0.1;\n      \n      layer.style.transform = `translateX(${translateX}px) translateY(${translateY}px) translateZ(${depth * 100}px)`;\n    });\n  });\n  \n  // Reset when mouse leaves\n  card.addEventListener('mouseleave', () => {\n    content.style.transform = 'rotateX(0deg) rotateY(0deg)';\n    \n    layers.forEach(layer => {\n      const depth = layer.getAttribute('data-depth');\n      layer.style.transform = `translateZ(${depth * 100}px)`;\n    });\n  });\n}\n\ninitParallaxTilt();"
    },
    {
        "id": "3d-holographic-card",
        "title": "3D Holographic Card",
        "description": "A stunning holographic card with prismatic color effects, depth, and dynamic light reflections.",
        "category": "3d",
        "tags": ["3d", "holographic", "prismatic", "depth", "reflection"],
        "html": "<div class=\"holographic-container\">\n  <div class=\"holographic-card\">\n    <div class=\"holo-overlay\"></div>\n    <div class=\"holo-shine\"></div>\n    <div class=\"holo-content\">\n      <div class=\"holo-icon\">\n        <svg viewBox=\"0 0 24 24\" width=\"60\" height=\"60\">\n          <path d=\"M12,2L1,21H23L12,2M12,6L19.5,19H4.5L12,6Z\" fill=\"currentColor\"/>\n        </svg>\n      </div>\n      <h3 class=\"holo-title\">Holographic</h3>\n      <p class=\"holo-subtitle\">AnimX Premium</p>\n    </div>\n  </div>\n  <div class=\"holo-instruction\">Move mouse over the card</div>\n</div>",
        "css": ".holographic-container {\n  width: 100%;\n  height: 300px;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  background: linear-gradient(135deg, #111 0%, #222 100%);\n  border-radius: 12px;\n  overflow: hidden;\n  position: relative;\n}\n\n.holographic-card {\n  width: 250px;\n  height: 180px;\n  position: relative;\n  border-radius: 12px;\n  overflow: hidden;\n  transform-style: preserve-3d;\n  transform: perspective(1000px) rotateX(10deg) rotateY(0deg);\n  box-shadow: 0 30px 60px rgba(0, 0, 0, 0.4);\n  transition: transform 0.2s ease;\n  cursor: pointer;\n  background: #000;\n}\n\n.holo-overlay {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(135deg, \n    rgba(124, 77, 255, 0.4) 0%, \n    rgba(255, 77, 124, 0.4) 20%, \n    rgba(77, 202, 255, 0.4) 40%, \n    rgba(77, 255, 96, 0.4) 60%, \n    rgba(255, 202, 77, 0.4) 80%, \n    rgba(255, 77, 248, 0.4) 100%);\n  mix-blend-mode: color-dodge;\n  opacity: 0.6;\n  z-index: 2;\n}\n\n.holo-shine {\n  position: absolute;\n  top: -100%;\n  left: -100%;\n  width: 300%;\n  height: 300%;\n  background: linear-gradient(135deg, \n    rgba(255, 255, 255, 0.1) 0%, \n    rgba(255, 255, 255, 0.4) 20%, \n    rgba(255, 255, 255, 0.05) 40%,\n    rgba(255, 255, 255, 0.3) 60%, \n    rgba(255, 255, 255, 0.05) 80%, \n    rgba(255, 255, 255, 0.2) 100%);\n  transform: rotate(45deg);\n  filter: blur(3px);\n  mix-blend-mode: overlay;\n  z-index: 3;\n  opacity: 0;\n  transition: opacity 0.3s ease-out;\n}\n\n.holo-content {\n  position: relative;\n  z-index: 4;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  padding: 20px;\n  transform: translateZ(30px);\n  text-align: center;\n}\n\n.holo-icon {\n  font-size: 3rem;\n  color: rgba(255, 255, 255, 0.95);\n  margin-bottom: 15px;\n  filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.7));\n  transform: translateZ(40px);\n}\n\n.holo-title {\n  color: rgba(255, 255, 255, 0.95);\n  font-size: 1.8rem;\n  font-weight: 700;\n  text-transform: uppercase;\n  letter-spacing: 2px;\n  margin: 0 0 5px;\n  filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.8));\n  transform: translateZ(20px);\n}\n\n.holo-subtitle {\n  color: rgba(255, 255, 255, 0.8);\n  font-size: 0.9rem;\n  letter-spacing: 1px;\n  margin: 5px 0;\n  transform: translateZ(10px);\n}\n\n.holo-instruction {\n  position: absolute;\n  bottom: 20px;\n  color: rgba(255, 255, 255, 0.6);\n  font-size: 0.8rem;\n  letter-spacing: 1px;\n  opacity: 0.7;\n}\n\n/* Prismatic edges effect */\n.holographic-card::before {\n  content: '';\n  position: absolute;\n  top: -5px;\n  left: -5px;\n  right: -5px;\n  bottom: -5px;\n  background: linear-gradient(135deg, \n    rgba(124, 77, 255, 0.5) 0%, \n    rgba(255, 77, 124, 0.5) 20%, \n    rgba(77, 202, 255, 0.5) 40%, \n    rgba(77, 255, 96, 0.5) 60%, \n    rgba(255, 202, 77, 0.5) 80%, \n    rgba(255, 77, 248, 0.5) 100%);\n  border-radius: 16px;\n  z-index: 1;\n  animation: edge-glow 10s linear infinite;\n  filter: blur(3px);\n  opacity: 0.7;\n  mix-blend-mode: screen;\n  pointer-events: none;\n}\n\n@keyframes edge-glow {\n  0% { background-position: 0% 50%; }\n  100% { background-position: 100% 50%; }\n}",
        "js": "function initHolographicCard() {\n  const container = document.querySelector('.holographic-container');\n  const card = document.querySelector('.holographic-card');\n  const shine = document.querySelector('.holo-shine');\n  \n  if (!container || !card || !shine) return;\n  \n  let rect = card.getBoundingClientRect();\n  let mouseX = 0;\n  let mouseY = 0;\n  \n  // Handle window resize\n  window.addEventListener('resize', () => {\n    rect = card.getBoundingClientRect();\n  });\n  \n  // Handle mouse movement for container\n  container.addEventListener('mousemove', (e) => {\n    rect = card.getBoundingClientRect();\n    mouseX = e.clientX - rect.left - rect.width / 2;\n    mouseY = e.clientY - rect.top - rect.height / 2;\n    \n    // Calculate rotation based on mouse position\n    const rotateY = mouseX * 0.07; \n    const rotateX = -mouseY * 0.1;\n    \n    // Apply rotation to card\n    card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateZ(10px)`;\n    \n    // Apply shine effect\n    const shineX = (e.clientX - rect.left) / rect.width * 100;\n    const shineY = (e.clientY - rect.top) / rect.height * 100;\n    \n    shine.style.opacity = '1';\n    shine.style.backgroundPosition = `${shineX}% ${shineY}%`;\n    shine.style.transform = `rotate(45deg) translate(${mouseX * 0.03}px, ${mouseY * 0.03}px)`;\n  });\n  \n  // Handle mouse exit\n  container.addEventListener('mouseleave', () => {\n    // Reset card rotation\n    card.style.transform = 'perspective(1000px) rotateX(10deg) rotateY(0deg) translateZ(0)';\n    \n    // Reset shine effect\n    shine.style.opacity = '0';\n  });\n  \n  // Add dynamic color shifting to content elements\n  const colorShift = () => {\n    const time = Date.now() * 0.001;\n    const content = document.querySelector('.holo-content');\n    if (content) {\n      const hue = ((Math.sin(time) * 0.5 + 0.5) * 360 + 230) % 360;\n      content.style.filter = `hue-rotate(${hue}deg)`;\n      requestAnimationFrame(colorShift);\n    }\n  };\n  \n  // Start color shifting animation\n  colorShift();\n}\n\n// Initialize the holographic card\ninitHolographicCard();"
    }
] 